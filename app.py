from flask import Flask, render_template, request, jsonify, url_for, session, redirect
from strategy.llm_generator import LLMGenerator
from strategy.strategy_selector import StrategySelector
from user_bio.user_info_manager import UserInfoManager
from bson import ObjectId
import secrets
import os
import time
import csv
import numpy as np
from werkzeug.utils import secure_filename
from speech.baidu_speech_recognizer import BaiduSpeechRecognizer
from emotion_detection.emotion_recognizer import EmotionRecognizer

try:
    from pydub import AudioSegment
    PYDUB_AVAILABLE = True
except ImportError:
    PYDUB_AVAILABLE = False
    print("Warning: pydub not available, audio processing will be limited")

app = Flask(__name__)
app.secret_key = secrets.token_hex(16)

generator = LLMGenerator()
selector = StrategySelector()
speech_recognizer = BaiduSpeechRecognizer()
emotion_recognizer = EmotionRecognizer()
user_info_manager = UserInfoManager()

# Lazily initialized tone_emotion analyzer
tone_analyzer = None

def get_tone_analyzer():
    """Lazily initialize tone_emotion analyzer"""
    global tone_analyzer
    if tone_analyzer is None:
        try:
            from emotion_detection.tone_emotion import VoiceEmotionAnalyzer
            tone_analyzer = VoiceEmotionAnalyzer()
            tone_analyzer.train_with_demo_data()
            print("‚úÖ Tone emotion analyzer initialized successfully")
        except Exception as e:
            print(f"‚ùå Failed to initialize tone emotion analyzer: {e}")
            tone_analyzer = None
    return tone_analyzer

def get_dynamic_weights(text_length: int, audio_quality: float = 0.5, emotion_type: str = None):
    """
    Dynamically adjust weights based on specific conditions
    
    Args:
        text_length: Text length
        audio_quality: Audio quality score (0-1), default 0.5
        emotion_type: Emotion type (optional)
    """
    base_text_weight = 0.7
    base_tone_weight = 0.3
    
    # Adjust based on text length
    if text_length < 10:  # Short text, increase tone weight
        text_weight = base_text_weight - 0.2
        tone_weight = base_tone_weight + 0.2
    elif text_length > 50:  # Long text, increase text weight
        text_weight = base_text_weight + 0.1
        tone_weight = base_tone_weight - 0.1
    else:
        text_weight = base_text_weight
        tone_weight = base_tone_weight
    
    # Adjust based on audio quality
    if audio_quality < 0.5:  # Low quality audio, increase text weight
        text_weight += 0.1
        tone_weight -= 0.1
    elif audio_quality > 0.8:  # High quality audio, increase tone weight
        text_weight -= 0.1
        tone_weight += 0.1
    
    # Adjust based on emotion type
    if emotion_type in ['anger', 'excitement']:  # Emotions with obvious tone
        text_weight -= 0.1
        tone_weight += 0.1
    
    # Ensure weights are in reasonable range
    text_weight = max(0.1, min(0.9, text_weight))
    tone_weight = max(0.1, min(0.9, tone_weight))
    
    return text_weight, tone_weight

def combine_emotions(text_emotion: dict, tone_emotion: dict, text_weight: float, tone_weight: float) -> dict:
    """
    Combine text emotion and tone emotion
    
    Args:
        text_emotion: Text emotion analysis result
        tone_emotion: Tone emotion analysis result
        text_weight: Text emotion weight
        tone_weight: Tone emotion weight
    
    Returns:
        Combined emotion result
    """
    if not tone_emotion:
        return text_emotion
    
    combined = {}
    for key in ["joy", "sadness", "anger", "intensity"]:
        text_val = text_emotion.get(key, 0.0)
        tone_val = tone_emotion.get(key, 0.0)
        
        # Weighted average
        combined[key] = (text_val * text_weight + tone_val * tone_weight) / (text_weight + tone_weight)
        combined[key] = max(0.0, min(1.0, combined[key]))
    
    return combined

def estimate_audio_quality(audio_path: str) -> float:
    """
    Estimate audio quality score (0-1)
    
    Args:
        audio_path: Audio file path
    
    Returns:
        Audio quality score
    """
    try:
        import librosa
        audio_data, sr = librosa.load(audio_path, sr=16000)
        
        # Calculate audio quality metrics
        # 1. Signal-to-noise ratio (simplified)
        rms = np.sqrt(np.mean(np.square(audio_data)))
        snr_score = min(1.0, rms * 10)  # Simplified SNR score
        
        # 2. Audio duration
        duration = len(audio_data) / sr
        duration_score = min(1.0, duration / 10)  # 10 seconds for full score
        
        # 3. Spectral energy distribution
        spectral_centroid = librosa.feature.spectral_centroid(y=audio_data, sr=sr).mean()
        spectral_score = min(1.0, spectral_centroid / 2000)  # 2000Hz for full score
        
        # Comprehensive score
        quality_score = (snr_score * 0.4 + duration_score * 0.3 + spectral_score * 0.3)
        
        return max(0.1, min(1.0, quality_score))
        
    except Exception as e:
        print(f"Audio quality assessment failed: {e}")
        return 0.5  # Default medium quality

# User emotion history data storage (in memory, recommend using database in production)
user_emotion_history = {}

# User warning history data storage (in memory, recommend using database in production)
user_warning_history = {}

@app.route("/")
def index():
    # Check if user is logged in
    if "user_id" in session:
        return render_template("index.html")
    else:
        return render_template("login.html")

@app.route("/register")
def register():
    return render_template("minimal_registration.html")

@app.route("/chat")
def chat_page():
    if "user_id" not in session:
        return redirect("/")
    return render_template("index.html")

@app.route("/api/users", methods=["POST"])
def create_user():
    """Create new user"""
    data = request.json
    user_ip = request.remote_addr
    
    # Validate required fields
    if not all(key in data for key in ["name", "age", "gender", "password"]):
        return jsonify({"error": "Please fill in all required information"}), 400
    
    # Create user
    user_id = user_info_manager.create_user(data, user_ip)
    session["user_id"] = user_id
    session["history"] = []
    
    # Initialize user emotion history
    user_emotion_history[user_id] = []
    user_warning_history[user_id] = []
    
    return jsonify({
        "status": "success",
        "user_id": user_id,
        "message": "User created successfully"
    }), 201

@app.route("/api/login", methods=["POST"])
def login():
    """User login"""
    data = request.json
    
    if not all(key in data for key in ["username", "password"]):
        return jsonify({"error": "Please enter username and password"}), 400
    
    # Verify user
    user = user_info_manager.authenticate_user(data["username"], data["password"])
    
    if user:
        user_id = user["_id"]
        session["user_id"] = user_id
        session["history"] = []
        
        # Initialize user emotion history (if not exists)
        if user_id not in user_emotion_history:
            user_emotion_history[user_id] = []
        if user_id not in user_warning_history:
            user_warning_history[user_id] = []
        
        return jsonify({
            "status": "success",
            "message": "Login successful"
        }), 200
    else:
        return jsonify({"error": "Username or password incorrect"}), 401

@app.route("/api/logout")
def logout():
    """User logout"""
    session.clear()
    return jsonify({"status": "success", "message": "Logged out"}), 200

@app.route("/chat", methods=["POST"])
def chat():
    try:
        if not request.json:
            return jsonify({"error": "Invalid request format"}), 400
        
        user_input = request.json.get("message")
        if not user_input:
            return jsonify({"error": "Message content cannot be empty"}), 400

        user_id = session.get("user_id")
        if not user_id:
            return jsonify({"error": "User not logged in"}), 401

        history = session.get("history", [])
        # Ensure all elements in history are strings
        if not isinstance(history, list):
            history = []
        # Filter out non-string elements
        history = [item for item in history if isinstance(item, str)]
        history.append(user_input)

        # Emotion analysis
        try:
            print(f"\n=== Emotion Analysis Started ===")
            print(f"User input: '{user_input}'")
            
            emotion_scores = emotion_recognizer.analyze_emotion_deepseek(user_input)
            print(f"üß† Emotion detection results: {emotion_scores}")
            
            emotion_intensity = emotion_scores.get("intensity", 0.5)
            print(f"üìä Emotion intensity: {emotion_intensity}")
            
            liwc_score = emotion_recognizer.liwc_score(user_input)
            liwc_score = {k: float(v) for k, v in liwc_score.items()}
            print(f"üîç LIWC analysis results: {liwc_score}")
            print(f"=== Emotion Analysis Ended ===\n")
            
            # Write emotion trend data
            user_info_manager.save_emotion_data(user_id, emotion_scores)
            
            # Update user emotion history data
            if user_id not in user_emotion_history:
                user_emotion_history[user_id] = []
            
            # Add current emotion data to history
            current_sadness = emotion_scores.get("sadness", 0.0)
            user_emotion_history[user_id].append(current_sadness)
            
            # Keep recent 20 conversations' emotion data
            if len(user_emotion_history[user_id]) > 20:
                user_emotion_history[user_id] = user_emotion_history[user_id][-20:]
            
            # Update long-term sadness log
            selector.log_long_term_sadness(current_sadness)
            
        except Exception as e:
            print(f"ÊÉÖÊÑüÂàÜÊûêÂ§±Ë¥•: {e}")
            emotion_scores = {"sadness": 0.2, "joy": 0.6, "anger": 0.1, "intensity": 0.5}
            emotion_intensity = 0.5
            liwc_score = {}
            current_sadness = 0.2

        # Get user information
        user_info = user_info_manager.get_user(user_id)
        print(f"DEBUG: user_id = {user_id}")
        print(f"DEBUG: user_info = {user_info}")
        
        # Get user emotion history window data
        window_sadness_scores = user_emotion_history.get(user_id, [])
        
        # Strategy selection (add window_sadness_scores parameter)
        print(f"=== Á≠ñÁï•ÈÄâÊã©ÂºÄÂßã ===")
        strategy = selector.select_strategy(
            emotion_scores, emotion_intensity, history, liwc_score, user_input, window_sadness_scores, user_info
        )
        print(f"üéØ ÈÄâÊã©ÁöÑÁ≠ñÁï•: {strategy.get('matched_rule', 'Unknown')}")
        print(f"üí¨ ÂºïÂØºËØ≠: {strategy.get('ÂºïÂØºËØ≠', 'N/A')}")
        
        # Check keyword warning results
        keyword_warning_result = selector.check_critical_keywords(user_input)
        print(f"‚ö†Ô∏è ÂÖ≥ÈîÆËØçÈ¢ÑË≠¶: {keyword_warning_result}")
        
        # Check early warning results
        early_warning_result = selector.check_early_warning(
            window_sadness_scores, 
            emotion_scores.get("sadness", 0.0), 
            liwc_score
        )
        print(f"üö® Êó©ÊúüÈ¢ÑË≠¶: {early_warning_result}")
        print(f"=== Á≠ñÁï•ÈÄâÊã©ÁªìÊùü ===\n")
        
        # Record warning history (user isolation)
        from datetime import datetime
        current_time = datetime.now()
        
        # If keyword warning is triggered, record to user warning history
        if keyword_warning_result["triggered"]:
            warning_record = {
                "timestamp": current_time,
                "type": "keyword_warning",
                "level": keyword_warning_result["level"],
                "reason": keyword_warning_result["reason"],
                "keywords": keyword_warning_result.get("keywords", []),
                "user_input": user_input
            }
            user_warning_history[user_id].append(warning_record)
        
        # If early warning is triggered, record to user warning history
        if early_warning_result["triggered"]:
            warning_record = {
                "timestamp": current_time,
                "type": "early_warning",
                "level": early_warning_result["level"],
                "reason": early_warning_result["reason"],
                "user_input": user_input
            }
            user_warning_history[user_id].append(warning_record)
        
        # Adjust response strategy based on warning level
        if keyword_warning_result["triggered"]:
            # Keyword warning: highest priority, directly use strategy selector's result
            strategy["keyword_warning"] = keyword_warning_result
        elif early_warning_result["triggered"]:
            warning_level = early_warning_result["level"]
            warning_reason = early_warning_result["reason"]
            
            # Select corresponding response strategy based on warning level
            if warning_level == "severe":
                # Severe warning: urgent concern
                strategy["ÂºïÂØºËØ≠"] = f"ÊàëÊ≥®ÊÑèÂà∞{warning_reason}ÔºåËøôËÆ©ÊàëÈùûÂ∏∏ÊãÖÂøÉ‰Ω†ÁöÑÁä∂ÊÄÅ„ÄÇ‰Ω†ÊÑøÊÑèÂíåÊàëËØ¶ÁªÜËÅäËÅäÂêóÔºüÂ¶ÇÊûúÈúÄË¶ÅÁöÑËØùÔºåÊàëÂª∫ËÆÆÊàë‰ª¨ÂèØ‰ª•ËÅîÁ≥ª‰∏ì‰∏öÁöÑÂøÉÁêÜÊîØÊåÅËµÑÊ∫ê„ÄÇ"
                strategy["ËØ≠Ê∞î"] = "Á¥ßÊÄ•ÂÖ≥Âàá"
                strategy["ÁõÆÊ†á"] = "Á´ãÂç≥ÊÉÖÁª™Âπ≤È¢ÑÔºåÂª∫ËÆÆËΩ¨‰ªã‰∏ì‰∏öÊîØÊåÅ"
                strategy["early_warning"] = {
                    "level": warning_level,
                    "reason": warning_reason,
                    "action": "Á´ãÂç≥ÂÖ≥Ê≥®ÔºåÂª∫ËÆÆ‰∫∫Â∑•‰ªãÂÖ•"
                }
            elif warning_level == "moderate":
                # Moderate warning: caring guidance
                strategy["ÂºïÂØºËØ≠"] = f"ÊàëÊ≥®ÊÑèÂà∞{warning_reason}Ôºå‰Ω†ÊúÄËøëÊòØ‰∏çÊòØÈÅáÂà∞‰∫Ü‰∏Ä‰∫õÂõ∞ÈöæÔºüÊÑøÊÑèÂíåÊàëËÅäËÅäÂêóÔºüÊàë‰ºö‰∏ÄÁõ¥Èô™ÁùÄ‰Ω†„ÄÇ"
                strategy["ËØ≠Ê∞î"] = "ÂÖ≥ÂàáÂºïÂØº"
                strategy["ÁõÆÊ†á"] = "‰∏ªÂä®ÂÖ≥ÊÄÄÔºåÈ¢ÑÈò≤ÊÉÖÁª™ÊÅ∂Âåñ"
                strategy["early_warning"] = {
                    "level": warning_level,
                    "reason": warning_reason,
                    "action": "ÈúÄË¶ÅÊåÅÁª≠ÂÖ≥Ê≥®ÔºåÂª∫ËÆÆÂ¢ûÂä†ÂÖ≥ÊÄÄÈ¢ëÁéá"
                }
            elif warning_level == "mild":
                # Mild warning: gentle care
                strategy["ÂºïÂØºËØ≠"] = f"ÊàëÊ≥®ÊÑèÂà∞{warning_reason}Ôºå‰Ω†ÊúÄËøëÂøÉÊÉÖÊÄé‰πàÊ†∑ÔºüÊúâ‰ªÄ‰πàÊÉ≥ÂíåÊàëÂàÜ‰∫´ÁöÑÂêóÔºü"
                strategy["ËØ≠Ê∞î"] = "Ê∏©ÂíåÂÖ≥ÊÄÄ"
                strategy["ÁõÆÊ†á"] = "Â¢ûÂä†ÂÖ≥ÊÄÄÈ¢ëÁéáÔºåÈ¢ÑÈò≤ÈóÆÈ¢òÂèëÂ±ï"
                strategy["early_warning"] = {
                    "level": warning_level,
                    "reason": warning_reason,
                    "action": "ÈïøÊúüÊÉÖÁª™ÂÅè‰ΩéÔºåÂª∫ËÆÆÂÆöÊúüÂÖ≥ÊÄÄ"
                }
        
        # Generate reply
        reply = generator.generate_response(user_input, strategy)
        
        # Check if need to ask user information
        next_question = strategy.get("next_question")
        if next_question:
            reply = user_info_manager.integrate_question_naturally(reply, next_question, user_input)
        
        # Suggest questionnaire in special cases
        if strategy.get("recommend_gds", False):
            reply += "\nüìù Âª∫ËÆÆ‰Ω†Â°´ÂÜô‰∏Ä‰∏™ÁÆÄÁü≠ÁöÑËá™ËØÑÈóÆÂç∑ÔºàGDSÔºâÔºåËøôÊúâÂä©‰∫éÊàë‰ª¨Êõ¥Â•ΩÂú∞‰∫ÜËß£‰Ω†ÁöÑÊÉÖÁª™Áä∂ÊÄÅ„ÄÇ"

        # Save conversation to database
        user_info_manager.save_conversation(user_id, user_input, reply, emotion_scores)
        
        # Ensure reply is string type
        if isinstance(reply, str):
            history.append(reply)
        session["history"] = history

        # Return response with warning information
        response_data = {
            "reply": reply,
            "emotion": emotion_scores,
            "liwc": liwc_score,
            "next_question": next_question
        }
        
        # If there's keyword warning, add to response
        if keyword_warning_result["triggered"]:
            response_data["keyword_warning"] = keyword_warning_result
            response_data["show_alert"] = True
            response_data["alert_message"] = f"‚ö†Ô∏è Ê£ÄÊµãÂà∞Âç±Èô©ÂÖ≥ÈîÆËØçÔºÅ\n{keyword_warning_result['reason']}\nÂª∫ËÆÆÁ´ãÂç≥‰∫∫Â∑•‰ªãÂÖ•„ÄÇ"
        
        # If there's early warning, add to response
        elif early_warning_result["triggered"]:
            response_data["early_warning"] = early_warning_result
            response_data["show_alert"] = True
            response_data["alert_message"] = f"‚ö†Ô∏è ÊÉÖÁª™È¢ÑË≠¶ÔºÅ\n{early_warning_result['reason']}\n{early_warning_result['suggested_action']}"

        return jsonify(response_data)
    except Exception as e:
        return jsonify({"error": f"Â§ÑÁêÜÊ∂àÊÅØÂ§±Ë¥•: {str(e)}"}), 500

@app.route("/chat_audio", methods=["POST"])
def chat_audio():
    temp_path = None
    try:
        if 'audio' not in request.files:
            return jsonify({'error': 'Ê≤°Êúâ‰∏ä‰º†Èü≥È¢ëÊñá‰ª∂'}), 400
        
        audio_file = request.files['audio']
        if audio_file.filename == '':
            return jsonify({'error': 'Ê≤°ÊúâÈÄâÊã©Êñá‰ª∂'}), 400
        
        # Check file size
        audio_file.seek(0, 2)
        file_size = audio_file.tell()
        audio_file.seek(0)
        
        if file_size > 10 * 1024 * 1024:
            return jsonify({'error': 'Èü≥È¢ëÊñá‰ª∂ËøáÂ§ßÔºåËØ∑ÈÄâÊã©Â∞è‰∫é10MBÁöÑÊñá‰ª∂'}), 400
        
        # Save temporary file
        tmp_dir = os.path.join(os.path.dirname(__file__), 'tmp')
        os.makedirs(tmp_dir, exist_ok=True)
        filename = secure_filename(audio_file.filename or 'audio.wav')
        temp_path = os.path.join(tmp_dir, filename)
        audio_file.save(temp_path)
        
        # Audio transcoding
        try:
            audio = AudioSegment.from_file(temp_path)
            audio = audio.set_frame_rate(16000).set_channels(1).set_sample_width(2)
            audio.export(temp_path, format='wav')
        except Exception as e:
            print(f'Èü≥È¢ëËΩ¨Á†ÅÂ§±Ë¥•: {e}')
        
        # Speech recognition
        try:
            text = speech_recognizer.recognize_file(temp_path)
        except Exception as e:
            text = None
            print(f"ËØ≠Èü≥ËØÜÂà´Â§±Ë¥•: {e}")
        
        if not text:
            return jsonify({
                'error': 'ËØ≠Èü≥ËØÜÂà´Â§±Ë¥•ÔºåËØ∑Ê£ÄÊü•Èü≥È¢ëË¥®ÈáèÊàñÈáçÊñ∞ÂΩïÂà∂',
                'text': '',
                'reply': 'Êä±Ê≠âÔºåÊàëÊ≤°ÊúâÂê¨Ê∏ÖÊ•öÊÇ®ËØ¥ÁöÑËØùÔºåËØ∑ÊÇ®ÈáçÊñ∞ËØ¥‰∏ÄÈÅç„ÄÇ'
            }), 200
        
        # ===== NEW: Tone emotion analysis =====
        tone_emotion_result = None
        try:
            analyzer = get_tone_analyzer()  # Lazy initialization
            if analyzer:
                tone_emotion_result = analyzer.analyze_audio_file(temp_path)
                print(f"üéµ Èü≥Ë∞ÉÊÉÖÁª™ÂàÜÊûêÁªìÊûú: {tone_emotion_result}")
            else:
                print("‚ö†Ô∏è Tone emotion analyzer not available")
        except Exception as e:
            print(f"‚ùå Èü≥Ë∞ÉÊÉÖÁª™ÂàÜÊûêÂ§±Ë¥•: {e}")
            tone_emotion_result = None
        
        # ===== Text emotion analysis =====
        try:
            text_emotion = emotion_recognizer.analyze_emotion_deepseek(text)
            print(f"üìù ÊñáÊú¨ÊÉÖÁª™ÂàÜÊûêÁªìÊûú: {text_emotion}")
            
            # ===== Dynamic weight calculation =====
            text_length = len(text)
            audio_quality = estimate_audio_quality(temp_path)
            
            # Determine emotion type based on text emotion
            emotion_type = None
            if text_emotion.get("anger", 0) > 0.6:
                emotion_type = "anger"
            elif text_emotion.get("joy", 0) > 0.6:
                emotion_type = "excitement"
            
            text_weight, tone_weight = get_dynamic_weights(text_length, audio_quality, emotion_type)
            print(f"‚öñÔ∏è Âä®ÊÄÅÊùÉÈáç - ÊñáÊú¨: {text_weight:.2f}, Èü≥Ë∞É: {tone_weight:.2f}")
            
            # ===== Combine text and tone emotions =====
            if tone_emotion_result:
                combined_emotion = combine_emotions(text_emotion, tone_emotion_result, text_weight, tone_weight)
                emotion_scores = combined_emotion
                print(f"üéØ ÁªìÂêàÂêéÊÉÖÁª™ÁªìÊûú: {emotion_scores}")
            else:
                emotion_scores = text_emotion
                print(f"üìù ‰ªÖ‰ΩøÁî®ÊñáÊú¨ÊÉÖÁª™: {emotion_scores}")
            
            emotion_intensity = emotion_scores.get("intensity", 0.5)
            liwc_score = emotion_recognizer.liwc_score(text)
            liwc_score = {k: float(v) for k, v in liwc_score.items()}
            
            # Save emotion data
            user_id = session.get("user_id")
            if user_id:
                user_info_manager.save_emotion_data(user_id, emotion_scores)
            
        except Exception as e:
            print(f"‚ùå ÊÉÖÊÑüÂàÜÊûêÂ§±Ë¥•: {e}")
            emotion_scores = {"sadness": 0.2, "joy": 0.6, "anger": 0.1, "intensity": 0.5}
            emotion_intensity = 0.5
            liwc_score = {}
        
        # Strategy selection - use optimized conversation history
        user_id = session.get("user_id")
        if user_id:
            # Get recent conversation history from database to avoid session history overload
            recent_conversation_text = user_info_manager.get_recent_conversation_text(user_id, limit=5)
            # Add current user input to history
            history = [recent_conversation_text, text] if recent_conversation_text else [text]
        else:
            # If no user ID, use session history (backward compatibility)
            history = session.get("history", [])
        if not isinstance(history, list):
            history = []
        history = [item for item in history if isinstance(item, str)]
        history.append(text)
        
        user_info = user_info_manager.get_user(user_id) if user_id else None
        
        strategy = selector.select_strategy(
            emotion_scores, emotion_intensity, history, liwc_score, text, user_info
        )
        reply = generator.generate_response(text, strategy)
        
        # Check if user information needs to be asked
        next_question = strategy.get("next_question")
        if next_question:
            reply = user_info_manager.integrate_question_naturally(reply, next_question, text)
        
        # Save conversation records to database
        if user_id:
            user_info_manager.save_conversation(user_id, text, reply, emotion_scores)
        
        # Update session history (maintain backward compatibility)
        if isinstance(reply, str):
            session_history = session.get("history", [])
            if not isinstance(session_history, list):
                session_history = []
            session_history.append(text)
            session_history.append(reply)
            # Limit session history length to avoid excessive memory usage
            session_history = session_history[-10:]  # Keep only the last 10 rounds of conversation
            session["history"] = session_history
        
        return jsonify({
            'text': text,
            'reply': reply,
            'emotion': emotion_scores,
            'liwc': liwc_score,
            'tone_emotion': tone_emotion_result,  # New: tone emotion results
            'text_emotion': text_emotion,  # New: original text emotion
            'weights': {  # New: weight information used
                'text_weight': text_weight,
                'tone_weight': tone_weight,
                'audio_quality': audio_quality,
                'text_length': text_length
            },
            'next_question': next_question
        })
        
    except Exception as e:
        return jsonify({'error': f'Â§ÑÁêÜÈü≥È¢ëÂ§±Ë¥•: {str(e)}'}), 500
    finally:
        if temp_path and os.path.exists(temp_path):
            os.remove(temp_path)

@app.route("/api/users/<user_id>/info", methods=["PUT"])
def update_user_info(user_id):
    """Êõ¥Êñ∞Áî®Êà∑‰ø°ÊÅØÔºàÂ§ÑÁêÜÈóÆÈ¢òÂõûÁ≠îÂíåÊâãÂä®ÁºñËæëÔºâ"""
    try:
        data = request.json
        
        # Check if it's manual edit mode
        if "field" in data and "value" in data:
            # Manual edit mode
            field = data.get("field")
            value = data.get("value")
            
            # Êò†Â∞ÑÂ≠óÊÆµÂà∞ÈóÆÈ¢òÈîÆ
            field_to_question_map = {
                "basic_info.name": "name",
                "basic_info.age": "age", 
                "basic_info.gender": "gender",
                "family_relation.children_count": "children_count",
                "family_relation.spouse_status": "spouse_status",
                "family_relation.living_alone": "living_alone",
                "living_habits.hobbies": "hobbies",
                "living_habits.health_status": "health_status"
            }
            
            question_key = field_to_question_map.get(field)
            if not question_key:
                return jsonify({"error": "Êó†ÊïàÁöÑÂ≠óÊÆµ"}), 400
            
            # ÂàõÂª∫Êõ¥Êñ∞Êï∞ÊçÆ
            update_data = {
                "question_key": question_key,
                "answer": value
            }
            
            success = user_info_manager.update_user_info(user_id, update_data)
        else:
            # ÂéüÊúâÁöÑÈóÆÈ¢òÂõûÁ≠îÊ®°Âºè
            success = user_info_manager.update_user_info(user_id, data)
        
        if success:
            return jsonify({"status": "success", "message": "‰ø°ÊÅØÊõ¥Êñ∞ÊàêÂäü"}), 200
        else:
            return jsonify({"error": "Áî®Êà∑‰∏çÂ≠òÂú®ÊàñÊõ¥Êñ∞Â§±Ë¥•"}), 400
            
    except Exception as e:
        return jsonify({"error": f"Êõ¥Êñ∞Â§±Ë¥•: {str(e)}"}), 500

@app.route("/api/users/<user_id>/bio", methods=["GET"])
def get_user_bio(user_id):
    """Ëé∑ÂèñÁî®Êà∑ËØ¶ÁªÜ‰ø°ÊÅØ"""
    try:
        user_info = user_info_manager.get_user(user_id)
        if user_info:
            return jsonify({"status": "success", "user": user_info}), 200
        else:
            return jsonify({"error": "Áî®Êà∑‰∏çÂ≠òÂú®"}), 404
            
    except Exception as e:
        return jsonify({"error": f"Ëé∑ÂèñÂ§±Ë¥•: {str(e)}"}), 500

@app.route("/trend")
def trend():
    # Ê£ÄÊü•Áî®Êà∑ÊòØÂê¶Â∑≤ÁôªÂΩï
    user_id = session.get("user_id")
    if not user_id:
        return redirect("/")
    return render_template("trend_chart.html")

@app.route("/api/trend_data")
def trend_data():
    user_id = session.get("user_id")
    if not user_id:
        return jsonify({"error": "Áî®Êà∑Êú™ÁôªÂΩï"}), 401
    
    from visualization.trend_plotter import get_emotion_trend
    trend_data = get_emotion_trend(user_id)
    return jsonify(trend_data)

@app.route("/api/chat_history")
def get_chat_history():
    """Ëé∑ÂèñÁî®Êà∑ÂØπËØùÂéÜÂè≤"""
    user_id = session.get("user_id")
    if not user_id:
        return jsonify({"error": "Áî®Êà∑Êú™ÁôªÂΩï"}), 401
    
    history = session.get("history", [])
    return jsonify({"history": history})

@app.route("/api/warning_data")
def warning_data():
    """Ëé∑ÂèñÁî®Êà∑È¢ÑË≠¶ÂéÜÂè≤Êï∞ÊçÆ"""
    user_id = session.get("user_id")
    if not user_id:
        return jsonify({"error": "Áî®Êà∑Êú™ÁôªÂΩï"}), 401
    
    # Ëé∑ÂèñÁî®Êà∑È¢ÑË≠¶ÂéÜÂè≤
    warnings = user_warning_history.get(user_id, [])
    
    # ÊåâÊó•ÊúüÂàÜÁªÑÁªüËÆ°
    from collections import defaultdict
    from datetime import datetime
    
    daily_warnings = defaultdict(lambda: {"keyword_warnings": 0, "early_warnings": 0, "total": 0})
    
    for warning in warnings:
        if isinstance(warning, dict) and "timestamp" in warning:
            if isinstance(warning["timestamp"], datetime):
                date_str = warning["timestamp"].strftime("%Y-%m-%d")
            else:
                # Â¶ÇÊûúÊòØÂ≠óÁ¨¶‰∏≤ÔºåÂ∞ùËØïËß£Êûê
                try:
                    date_obj = datetime.fromisoformat(warning["timestamp"].replace('Z', '+00:00'))
                    date_str = date_obj.strftime("%Y-%m-%d")
                except:
                    continue
        else:
            continue
        
        daily_warnings[date_str]["total"] += 1
        
        if warning.get("type") == "keyword_warning":
            daily_warnings[date_str]["keyword_warnings"] += 1
        elif warning.get("type") == "early_warning":
            daily_warnings[date_str]["early_warnings"] += 1
    
    # ËΩ¨Êç¢‰∏∫ÂàóË°®Ê†ºÂºè
    warning_data = []
    for date, counts in sorted(daily_warnings.items()):
        warning_data.append({
            "date": date,
            "keyword_warnings": counts["keyword_warnings"],
            "early_warnings": counts["early_warnings"],
            "total": counts["total"]
        })
    
    return jsonify({
        "warning_data": warning_data,
        "total_warnings": len(warnings)
    })

@app.route("/user_bio")
def user_bio_page():
    user_id = session.get("user_id")
    if not user_id:
        return jsonify({"error": "Áî®Êà∑Êú™ÁôªÂΩï"}), 401
    
    return render_template("user_bio.html", user_id=user_id)

@app.route("/questionnaire", methods=["GET", "POST"])
def questionnaire():
    if request.method == "POST":
        answers = request.form.to_dict()

        # Â¶ÇÊûúÊúâ‰∫∫Ê≤°Â°´ÂÆå‰ºöÊä•Èîô
        if len(answers) < 15 or any(v == '' for v in answers.values()):
            return render_template("questionnaire.html", error_message="‚ö†Ô∏è ËØ∑ÂõûÁ≠îÂÆåÊâÄÊúâÈ¢òÁõÆÂÜçÊèê‰∫§Âì¶ÔΩû")
        
        score = sum(int(value) for value in answers.values())

        # ÂÅáËÆæ‰Ω†Â∑≤ÁªèÁôªÂΩïÂπ∂Êúâ user_id Â≠òÂú® session ‰∏≠
        user_id = session.get('user_id', 'anonymous')

        # ‰øùÂ≠òÂà∞ sessionÔºåÊñπ‰æøË∑≥ËΩ¨Âêé‰ΩøÁî®
        session['gds_answers'] = answers
        session['gds_score'] = score
        session['gds_user'] = user_id

        return redirect(url_for('gds_result'))
    
    return render_template("questionnaire.html")

@app.route("/gds_result")
def gds_result():
    score = session.get("gds_score", 0)
    answers = session.get("gds_answers", {})
    user_id = session.get("gds_user", "anonymous")

    # ‰øùÂ≠òÁªìÊûú
    file_path = 'user_bio/data/gds_results.csv'
    file_exists = os.path.isfile(file_path)

    with open(file_path, mode='a', newline='', encoding='utf-8') as f:
        writer = csv.writer(f)

        if not file_exists:
            header = ['username'] + [f'q{i}' for i in range(1, 16)] + ['score']
            writer.writerow(header)

        row = [user_id] + [answers.get(f'q{i}', '') for i in range(1, 16)] + [score]
        writer.writerow(row)

    # Ê†πÊçÆÂæóÂàÜÁîüÊàêÊñáÂ≠óÊèèËø∞
    score = int(score)
    if score <= 4:
        description = "Áä∂ÊÄÅËâØÂ•Ω üòä"
    elif score <= 8:
        description = "ÊúâËΩªÂ∫¶ÊäëÈÉÅÂÄæÂêë üòê"
    else:
        description = "ÂèØËÉΩÂ≠òÂú®ÊòéÊòæÊäëÈÉÅÔºåÂª∫ËÆÆËøõ‰∏ÄÊ≠•ËØÑ‰º∞ üòü"

    return render_template("gds_result.html", score=score, description=description)

if __name__ == "__main__":
    app.run(debug=True, port=5001)